{
  "name": "ssh2",
  "version": "0.4.11",
  "author": {
    "name": "Brian White",
    "email": "mscdex@mscdex.net"
  },
  "description": "SSH2 client and server modules written in pure JavaScript for node.js",
  "main": "./lib/client",
  "engines": {
    "node": ">=0.8.7"
  },
  "dependencies": {
    "readable-stream": "~1.0.0",
    "ssh2-streams": "~0.0.5"
  },
  "scripts": {
    "test": "node test/test.js"
  },
  "keywords": [
    "ssh",
    "ssh2",
    "sftp",
    "secure",
    "shell",
    "exec",
    "remote",
    "client"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mscdex/ssh2/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/mscdex/ssh2.git"
  },
  "readme": "Description\n===========\n\nSSH2 client and server modules written in pure JavaScript for [node.js](http://nodejs.org/).\n\nDevelopment/testing is done against OpenSSH (6.6 currently).\n\n[Changes from v0.3.x-v0.4.x](https://github.com/mscdex/ssh2/wiki/Changes-from-0.3.x-to-0.4.x)\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v0.8.7 or newer\n\n\nInstall\n=======\n\n    npm install ssh2\n\n\nClient Examples\n===============\n\n* Authenticate using keys and execute `uptime` on a server:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn = new Client();\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.exec('uptime', function(err, stream) {\n    if (err) throw err;\n    stream.on('close', function(code, signal) {\n      console.log('Stream :: close :: code: ' + code + ', signal: ' + signal);\n      conn.end();\n    }).on('data', function(data) {\n      console.log('STDOUT: ' + data);\n    }).stderr.on('data', function(data) {\n      console.log('STDERR: ' + data);\n    });\n  });\n}).connect({\n  host: '192.168.100.100',\n  port: 22,\n  username: 'frylock',\n  privateKey: require('fs').readFileSync('/here/is/my/key')\n});\n\n// example output:\n// Client :: ready\n// STDOUT:  17:41:15 up 22 days, 18:09,  1 user,  load average: 0.00, 0.01, 0.05\n//\n// Stream :: exit :: code: 0, signal: undefined\n// Stream :: close\n```\n\n* Authenticate using keys and start an interactive shell session:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn = new Client();\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.shell(function(err, stream) {\n    if (err) throw err;\n    stream.on('close', function() {\n      console.log('Stream :: close');\n      conn.end();\n    }).on('data', function(data) {\n      console.log('STDOUT: ' + data);\n    }).stderr.on('data', function(data) {\n      console.log('STDERR: ' + data);\n    });\n    stream.end('ls -l\\nexit\\n');\n  });\n}).connect({\n  host: '192.168.100.100',\n  port: 22,\n  username: 'frylock',\n  privateKey: require('fs').readFileSync('/here/is/my/key')\n});\n\n// example output:\n// Client :: ready\n// STDOUT: Last login: Sun Jun 15 09:37:21 2014 from 192.168.100.100\n//\n// STDOUT: ls -l\n// exit\n//\n// STDOUT: frylock@athf:~$ ls -l\n//\n// STDOUT: total 8\n//\n// STDOUT: drwxr-xr-x 2 frylock frylock 4096 Nov 18  2012 mydir\n//\n// STDOUT: -rw-r--r-- 1 frylock frylock   25 Apr 11  2013 test.txt\n//\n// STDOUT: frylock@athf:~$ exit\n//\n// STDOUT: logout\n//\n// Stream :: close\n```\n\n* Authenticate using password and send an HTTP request to port 80 on the server:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn = new Client();\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.forwardOut('192.168.100.102', 8000, '127.0.0.1', 80, function(err, stream) {\n    if (err) throw err;\n    stream.on('close', function() {\n      console.log('TCP :: CLOSED');\n      conn.end();\n    }).on('data', function(data) {\n      console.log('TCP :: DATA: ' + data);\n    }).end([\n      'HEAD / HTTP/1.1',\n      'User-Agent: curl/7.27.0',\n      'Host: 127.0.0.1',\n      'Accept: */*',\n      'Connection: close',\n      '',\n      ''\n    ].join('\\r\\n'));\n  });\n}).connect({\n  host: '192.168.100.100',\n  port: 22,\n  username: 'frylock',\n  password: 'nodejsrules'\n});\n\n// example output:\n// Client :: ready\n// TCP :: DATA: HTTP/1.1 200 OK\n// Date: Thu, 15 Nov 2012 13:52:58 GMT\n// Server: Apache/2.2.22 (Ubuntu)\n// X-Powered-By: PHP/5.4.6-1ubuntu1\n// Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT\n// Content-Encoding: gzip\n// Vary: Accept-Encoding\n// Connection: close\n// Content-Type: text/html; charset=UTF-8\n//\n//\n// TCP :: CLOSED\n```\n\n* Authenticate using password and forward remote connections on port 8000 to us:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn = new Client();\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.forwardIn('127.0.0.1', 8000, function(err) {\n    if (err) throw err;\n    console.log('Listening for connections on server on port 8000!');\n  });\n}).on('tcp connection', function(info, accept, reject) {\n  console.log('TCP :: INCOMING CONNECTION:');\n  console.dir(info);\n  accept().on('close', function() {\n    console.log('TCP :: CLOSED');\n  }).on('data', function(data) {\n    console.log('TCP :: DATA: ' + data);\n  }).end([\n    'HTTP/1.1 404 Not Found',\n    'Date: Thu, 15 Nov 2012 02:07:58 GMT',\n    'Server: ForwardedConnection',\n    'Content-Length: 0',\n    'Connection: close',\n    '',\n    ''\n  ].join('\\r\\n'));\n}).connect({\n  host: '192.168.100.100',\n  port: 22,\n  username: 'frylock',\n  password: 'nodejsrules'\n});\n\n// example output:\n// Client :: ready\n// Listening for connections on server on port 8000!\n//  (.... then from another terminal on the server: `curl -I http://127.0.0.1:8000`)\n// TCP :: INCOMING CONNECTION: { destIP: '127.0.0.1',\n//  destPort: 8000,\n//  srcIP: '127.0.0.1',\n//  srcPort: 41969 }\n// TCP DATA: HEAD / HTTP/1.1\n// User-Agent: curl/7.27.0\n// Host: 127.0.0.1:8000\n// Accept: */*\n//\n//\n// TCP :: CLOSED\n```\n\n* Authenticate using password and get a directory listing via SFTP:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn = new Client();\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.sftp(function(err, sftp) {\n    if (err) throw err;\n    sftp.readdir('foo', function(err, list) {\n      if (err) throw err;\n      console.dir(list);\n      conn.end();\n    });\n  });\n}).connect({\n  host: '192.168.100.100',\n  port: 22,\n  username: 'frylock',\n  password: 'nodejsrules'\n});\n\n// example output:\n// Client :: ready\n// [ { filename: 'test.txt',\n//     longname: '-rw-r--r--    1 frylock   frylock         12 Nov 18 11:05 test.txt',\n//     attrs:\n//      { size: 12,\n//        uid: 1000,\n//        gid: 1000,\n//        mode: 33188,\n//        atime: 1353254750,\n//        mtime: 1353254744 } },\n//   { filename: 'mydir',\n//     longname: 'drwxr-xr-x    2 frylock   frylock       4096 Nov 18 15:03 mydir',\n//     attrs:\n//      { size: 1048576,\n//        uid: 1000,\n//        gid: 1000,\n//        mode: 16877,\n//        atime: 1353269007,\n//        mtime: 1353269007 } } ]\n```\n\n* Connection hopping:\n\n```javascript\nvar Client = require('ssh2').Client;\n\nvar conn1 = new Client(),\n    conn2 = new Client();\n\nconn1.on('ready', function() {\n  console.log('FIRST :: connection ready');\n  conn1.exec('nc 192.168.1.2 22', function(err, stream) {\n    if (err) {\n      console.log('FIRST :: exec error: ' + err);\n      return conn1.end();\n    }\n    conn2.connect({\n      sock: stream,\n      username: 'user2',\n      password: 'password2',\n    });\n  });\n}).connect({\n  host: '192.168.1.1',\n  username: 'user1',\n  password: 'password1',\n});\n\nconn2.on('ready', function() {\n  console.log('SECOND :: connection ready');\n  conn2.exec('uptime', function(err, stream) {\n    if (err) {\n      console.log('SECOND :: exec error: ' + err);\n      return conn1.end();\n    }\n    stream.on('end', function() {\n      conn1.end(); // close parent (and this) connection\n    }).on('data', function(data) {\n      console.log(data.toString());\n    });\n  });\n});\n```\n\n* Forward X11 connections (xeyes):\n\n```javascript\nvar net = require('net'),\n    Client = require('ssh2').Client;\n\nvar conn = new Client();\n\nconn.on('x11', function(info, accept, reject) {\n  var xserversock = new net.Socket();\n  xserversock.on('connect', function() {\n    var xclientsock = accept();\n    xclientsock.pipe(xserversock).pipe(xclientsock);\n  });\n  // connects to localhost:0.0\n  xserversock.connect(6000, 'localhost');\n});\n\nconn.on('ready', function() {\n  conn.exec('xeyes', { x11: true }, function(err, stream) {\n    if (err) throw err;\n    var code = 0;\n    stream.on('end', function() {\n      if (code !== 0)\n        console.log('Do you have X11 forwarding enabled on your SSH server?');\n      conn.end();\n    }).on('exit', function(exitcode) {\n      code = exitcode;\n    });\n  });\n}).connect({\n  host: '192.168.1.1',\n  username: 'foo',\n  password: 'bar'\n});\n```\n\n* Dynamic (1:1) port forwarding using a SOCKSv5 proxy (using [socksv5](https://github.com/mscdex/socksv5)):\n\n```javascript\nvar socks = require('socksv5'),\n    Client = require('ssh2').Client;\n\nvar ssh_config = {\n  host: '192.168.100.1',\n  port: 22,\n  username: 'nodejs',\n  password: 'rules'\n};\n\nsocks.createServer(function(info, accept, deny) {\n  // NOTE: you could just use one ssh2 client connection for all forwards, but\n  // you could run into server-imposed limits if you have too many forwards open\n  // at any given time\n  var conn = new Client();\n  conn.on('ready', function() {\n    conn.forwardOut(info.srcAddr,\n                    info.srcPort,\n                    info.dstAddr,\n                    info.dstPort,\n                    function(err, stream) {\n      if (err) {\n        conn.end();\n        return deny();\n      }\n\n      var clientSocket;\n      if (clientSocket = accept(true)) {\n        stream.pipe(clientSocket).pipe(stream).on('close', function() {\n          conn.end();\n        });\n      } else\n        conn.end();\n    });\n  }).on('error', function(err) {\n    deny();\n  }).connect(ssh_config);\n}).listen(1080, 'localhost', function() {\n  console.log('SOCKSv5 proxy server started on port 1080');\n}).useAuth(socks.auth.None());\n\n// test with cURL:\n//   curl -i --socks5 localhost:1080 google.com\n```\n\n* Invoke an arbitrary subsystem (netconf in this example):\n\n```javascript\nvar Client = require('ssh2').Client,\n    xmlhello = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'+\n               '<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">'+\n               '    <capabilities>'+\n               '\t\t<capability>urn:ietf:params:netconf:base:1.0</capability>'+\n               '\t</capabilities>'+\n               '</hello>]]>]]>';\n\nvar conn = new Client();\n\nconn.on('ready', function() {\n  console.log('Client :: ready');\n  conn.subsys('netconf', function(err, stream) {\n    if (err) throw err;\n    stream.on('data', function(data) {\n      console.log(data);\n    }).write(xmlhello);\n  });\n}).connect({\n  host: '1.2.3.4',\n  port: 22,\n  username: 'blargh',\n  password: 'honk'\n});\n```\n\nServer Examples\n===============\n\n* Only allow password and public key authentication and command execution:\n\n```javascript\nvar fs = require('fs'),\n    crypto = require('crypto');\nvar buffersEqual = require('buffer-equal-constant-time'),\n    ssh2 = require('ssh2'),\n    utils = ssh2.utils;\n\nvar pubKey = utils.genPublicKey(utils.parseKey(fs.readFileSync('user.pub')));\n\nnew ssh2.Server({\n  privateKey: fs.readFileSync('host.key')\n}, function(client) {\n  console.log('Client connected!');\n\n  client.on('authentication', function(ctx) {\n    if (ctx.method === 'password'\n        && ctx.username === 'foo'\n        && ctx.password === 'bar')\n      ctx.accept();\n    else if (ctx.method === 'publickey'\n             && ctx.key.algo === pubKey.fulltype\n             && buffersEqual(ctx.key.data, pubKey.public)) {\n      if (ctx.signature) {\n        var verifier = crypto.createVerify(ctx.sigAlgo);\n        verifier.update(ctx.blob);\n        if (verifier.verify(pubKey.publicOrig, ctx.signature, 'binary'))\n          ctx.accept();\n        else\n          ctx.reject();\n      } else {\n        // if no signature present, that means the client is just checking\n        // the validity of the given public key\n        ctx.accept();\n      }\n    } else\n      ctx.reject();\n  }).on('ready', function() {\n    console.log('Client authenticated!');\n\n    client.on('session', function(accept, reject) {\n      var session = accept();\n      session.once('exec', function(accept, reject, info) {\n        console.log('Client wants to execute: ' + inspect(info.command));\n        var stream = accept();\n        stream.stderr.write('Oh no, the dreaded errors!\\n');\n        stream.write('Just kidding about the errors!\\n');\n        stream.exit(0);\n        stream.end();\n      });\n    });\n  }).on('end', function() {\n    console.log('Client disconnected');\n  });\n}).listen(0, '127.0.0.1', function() {\n  console.log('Listening on port ' + this.address().port);\n});\n```\n\n* SFTP only server:\n\n```javascript\nvar fs = require('fs');\nvar ssh2 = require('ssh2');\nvar OPEN_MODE = ssh2.SFTP_OPEN_MODE,\n    STATUS_CODE = ssh2.SFTP_STATUS_CODE;\n\nnew ssh2.Server({\n  privateKey: fs.readFileSync('host.key')\n}, function(client) {\n  console.log('Client connected!');\n\n  client.on('authentication', function(ctx) {\n    if (ctx.method === 'password'\n        && ctx.username === 'foo'\n        && ctx.password === 'bar')\n      ctx.accept();\n    else\n      ctx.reject();\n  }).on('ready', function() {\n    console.log('Client authenticated!');\n\n    client.on('session', function(accept, reject) {\n      var session = accept();\n      session.on('sftp', function(accept, reject) {\n        console.log('Client SFTP session');\n        var openFiles = {};\n        var handleCount = 0;\n        // `sftpStream` is an `SFTPStream` instance in server mode\n        // see: https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md\n        var sftpStream = accept();\n        sftpStream.on('OPEN', function(reqid, filename, flags, attrs) {\n          // only allow opening /tmp/foo.txt for writing\n          if (filename !== '/tmp/foo.txt' || !(flags & OPEN_MODE.WRITE))\n            return sftpStream.status(reqid, STATUS_CODE.FAILURE);\n          // create a fake handle to return to the client, this could easily\n          // be a real file descriptor number for example if actually opening\n          // the file on the disk\n          var handle = new Buffer(4);\n          openFiles[handleCount] = true;\n          handle.writeUInt32BE(handleCount++, 0, true);\n          sftpStream.handle(reqid, handle);\n          console.log('Opening file for write')\n        }).on('WRITE', function(reqid, handle, offset, data) {\n          if (handle.length !== 4 || !openFiles[handle.readUInt32BE(0, true)])\n            return sftpStream.status(reqid, STATUS_CODE.FAILURE);\n          // fake the write\n          sftpStream.status(reqid, STATUS_CODE.OK);\n          var inspected = require('util').inspect(data);\n          console.log('Write to file at offset %d: %s', offset, inspected);\n        }).on('CLOSE', function(reqid, handle) {\n          var fnum;\n          if (handle.length !== 4 || !openFiles[(fnum = handle.readUInt32BE(0, true))])\n            return sftpStream.status(reqid, STATUS_CODE.FAILURE);\n          delete openFiles[fnum];\n          sftpStream.status(reqid, STATUS_CODE.OK);\n          console.log('Closing file');\n        });\n      });\n    });\n  }).on('end', function() {\n    console.log('Client disconnected');\n  });\n}).listen(0, '127.0.0.1', function() {\n  console.log('Listening on port ' + this.address().port);\n});\n```\n\n\nAPI\n===\n\n`require('ssh2').Client` returns a **_Client_** constructor.\n\n`require('ssh2').Server` returns a **_Server_** constructor.\n\n`require('ssh2').utils` returns the [utility methods from `ssh2-streams`](https://github.com/mscdex/ssh2-streams#utility-methods).\n\n`require('ssh2').SFTP_STATUS_CODE` returns the [`SFTPStream.STATUS_CODE` from `ssh2-streams`](https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md#sftpstream-static-constants).\n\n`require('ssh2').SFTP_OPEN_MODE` returns the [`SFTPStream.OPEN_MODE` from `ssh2-streams`](https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md#sftpstream-static-constants).\n\nClient events\n-------------\n\n* **banner**(< _string_ >message, < _string_ >language) - A notice was sent by the server upon connection.\n\n* **ready**() - Authentication was successful.\n\n* **tcp connection**(< _object_ >details, < _function_ >accept, < _function_ >reject) - An incoming forwarded TCP connection is being requested. Calling `accept` accepts the connection and returns a `Channel` object. Calling `reject` rejects the connection and no further action is needed. `details` contains:\n\n    * **srcIP** - _string_ - The originating IP of the connection.\n\n    * **srcPort** - _integer_ - The originating port of the connection.\n\n    * **dstIP** - _string_ - The remote IP the connection was received on (given in earlier call to `forwardIn()`).\n\n    * **dstPort** - _integer_ - The remote port the connection was received on (given in earlier call to `forwardIn()`).\n\n* **x11**(< _object_ >details, < _function_ >accept, < _function_ >reject) - An incoming X11 connection is being requested. Calling `accept` accepts the connection and returns a `Channel` object. Calling `reject` rejects the connection and no further action is needed. `details` contains:\n\n    * **srcIP** - _string_ - The originating IP of the connection.\n\n    * **srcPort** - _integer_ - The originating port of the connection.\n\n* **keyboard-interactive**(< _string_ >name, < _string_ >instructions, < _string_ >instructionsLang, < _array_ >prompts, < _function_ >finish) - The server is asking for replies to the given `prompts` for keyboard-interactive user authentication. `name` is generally what you'd use as a window title (for GUI apps). `prompts` is an array of `{ prompt: 'Password: ', echo: false }` style objects (here `echo` indicates whether user input should be displayed on the screen). The answers for all prompts must be provided as an array of strings and passed to `finish` when you are ready to continue. Note: It's possible for the server to come back and ask more questions.\n\n* **change password**(< _string_ >message, < _string_ >language, < _function_ >done) - If using password-based user authentication, the server has requested that the user's password be changed. Call `done` with the new password.\n\n* **continue**() - Emitted when more requests/data can be sent to the server (after a `Client` method returned `false`).\n\n* **error**(< _Error_ >err) - An error occurred. A 'level' property indicates 'client-socket' for socket-level errors and 'client-ssh' for SSH disconnection messages. In the case of 'client-ssh' messages, there may be a 'description' property that provides more detail.\n\n* **end**() - The socket was disconnected.\n\n* **close**(< _boolean_ >hadError) - The socket was closed. `hadError` is set to `true` if this was due to error.\n\n\nClient methods\n--------------\n\n* **(constructor)**() - Creates and returns a new Client instance.\n\n* **connect**(< _object_ >config) - _(void)_ - Attempts a connection to a server using the information given in `config`:\n\n    * **host** - _string_ - Hostname or IP address of the server. **Default:** `'localhost'`\n\n    * **port** - _integer_ - Port number of the server. **Default:** `22`\n\n    * **forceIPv4** - _boolean_ - Only connect via resolved IPv4 address for `host`. **Default:** `false`\n\n    * **forceIPv6** - _boolean_ - Only connect via resolved IPv6 address for `host`. **Default:** `false`\n\n    * **hostHash** - _string_ - 'md5' or 'sha1'. The host's key is hashed using this method and passed to the **hostVerifier** function. **Default:** (none)\n\n    * **hostVerifier** - _function_ - Function that is passed a string hex hash of the host's key for verification purposes. Return `true` to continue with the handshake or `false` to reject and disconnect. **Default:** (auto-accept)\n\n    * **username** - _string_ - Username for authentication. **Default:** (none)\n\n    * **password** - _string_ - Password for password-based user authentication. **Default:** (none)\n\n    * **agent** - _string_ - Path to ssh-agent's UNIX socket for ssh-agent-based user authentication. **Windows users: set to 'pageant' for authenticating with Pageant or (actual) path to a cygwin \"UNIX socket.\"** **Default:** (none)\n\n    * **privateKey** - _mixed_ - _Buffer_ or _string_ that contains a private key for either key-based or hostbased user authentication (OpenSSH format). **Default:** (none)\n\n    * **passphrase** - _string_ - For an encrypted private key, this is the passphrase used to decrypt it. **Default:** (none)\n\n    * **localHostname** - _string_ - Along with **localUsername** and **privateKey**, set this to a non-empty string for hostbased user authentication. **Default:** (none)\n\n    * **localUsername** - _string_ - Along with **localHostname** and **privateKey**, set this to a non-empty string for hostbased user authentication. **Default:** (none)\n\n    * **tryKeyboard** - _boolean_ - Try keyboard-interactive user authentication if primary user authentication method fails. If you set this to `true`, you need to handle the `keyboard-interactive` event. **Default:** `false`\n\n    * **keepaliveInterval** - _integer_ - How often (in milliseconds) to send SSH-level keepalive packets to the server (in a similar way as OpenSSH's ServerAliveInterval config option). Set to 0 to disable. **Default:** `0`\n\n    * **keepaliveCountMax** - _integer_ - How many consecutive, unanswered SSH-level keepalive packets that can be sent to the server before disconnection (similar to OpenSSH's ServerAliveCountMax config option). **Default:** `3`\n\n    * **readyTimeout** - _integer_ - How long (in milliseconds) to wait for the SSH handshake to complete. **Default:** `20000`\n\n    * **strictVendor** - _boolean_ - Performs a strict server vendor check before sending vendor-specific requests, etc. (e.g. check for OpenSSH server when using `openssh_noMoreSessions()`) **Default:** `true`\n\n    * **sock** - _ReadableStream_ - A _ReadableStream_ to use for communicating with the server instead of creating and using a new TCP connection (useful for connection hopping).\n\n    * **agentForward** - _boolean_ - Set to `true` to use OpenSSH agent forwarding (`auth-agent@openssh.com`) for the life of the connection. `agent` must also be set to use this feature. **Default:** `false`\n\n    * **debug** - _function_ - Set this to a function that receives a single string argument to get detailed (local) debug information. **Default:** (none)\n\n**Authentication method priorities:** Password -> Private Key -> Agent (-> keyboard-interactive if `tryKeyboard` is `true`) -> Hostbased -> None\n\n* **exec**(< _string_ >command[, < _object_ >options], < _function_ >callback) - _boolean_ - Executes `command` on the server. Returns `false` if you should wait for the `continue` event before sending any more traffic. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Valid `options` properties are:\n\n    * **env** - _object_ - An environment to use for the execution of the command.\n\n    * **pty** - _mixed_ - Set to `true` to allocate a pseudo-tty with defaults, or an object containing specific pseudo-tty settings (see 'Pseudo-TTY settings'). Setting up a pseudo-tty can be useful when working with remote processes that expect input from an actual terminal (e.g. sudo's password prompt).\n\n    * **x11** - _mixed_ - Set to `true` to use defaults below, set to a number to specify a specific screen number, or an object with the following valid properties:\n\n        * **single** - _boolean_ - Allow just a single connection? **Default:** `false`\n\n        * **screen** - _number_ - Screen number to use **Default:** `0`\n\n* **shell**([[< _mixed_ >window,] < _object_ >options]< _function_ >callback) - _boolean_ - Starts an interactive shell session on the server, with an optional `window` object containing pseudo-tty settings (see 'Pseudo-TTY settings'). If `window === false`, then no pseudo-tty is allocated. `options` supports the `x11` option as described in exec(). `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **forwardIn**(< _string_ >remoteAddr, < _integer_ >remotePort, < _function_ >callback) - _boolean_ - Bind to `remoteAddr` on `remotePort` on the server and forward incoming TCP connections. `callback` has 2 parameters: < _Error_ >err, < _integer_ >port (`port` is the assigned port number if `remotePort` was 0). Returns `false` if you should wait for the `continue` event before sending any more traffic. Here are some special values for `remoteAddr` and their associated binding behaviors:\n\n    * '' - Connections are to be accepted on all protocol families supported by the server.\n\n    * '0.0.0.0' - Listen on all IPv4 addresses.\n\n    * '::' - Listen on all IPv6 addresses.\n\n    * 'localhost' - Listen on all protocol families supported by the server on loopback addresses only.\n\n    * '127.0.0.1' and '::1' - Listen on the loopback interfaces for IPv4 and IPv6, respectively.\n\n* **unforwardIn**(< _string_ >remoteAddr, < _integer_ >remotePort, < _function_ >callback) - _boolean_ - Unbind from `remoteAddr` on `remotePort` on the server and stop forwarding incoming TCP connections. Until `callback` is called, more connections may still come in. `callback` has 1 parameter: < _Error_ >err. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **forwardOut**(< _string_ >srcIP, < _integer_ >srcPort, < _string_ >dstIP, < _integer_ >dstPort, < _function_ >callback) - _boolean_ - Open a connection with `srcIP` and `srcPort` as the originating address and port and `dstIP` and `dstPort` as the remote destination address and port. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **sftp**(< _function_ >callback) - _boolean_ - Starts an SFTP session. `callback` has 2 parameters: < _Error_ >err, < _SFTPStream_ >sftp. For methods available on `sftp`, see the [`SFTPStream` client documentation](https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md) (except `read()` and `write()` are used instead of `readData()` and `writeData()` respectively, for convenience). Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **subsys**(< _string_ >subsystem, < _function_ >callback) - _boolean_ - Invokes `subsystem` on the server. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **end**() - _(void)_ - Disconnects the socket.\n\n* **openssh_noMoreSessions**(< _function_ >callback) - _boolean_ - OpenSSH extension that sends a request to reject any new sessions (e.g. exec, shell, sftp, subsys) for this connection. `callback` has 1 parameter: < _Error_ >err. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **openssh_forwardInStreamLocal**(< _string_ >socketPath, < _function_ >callback) - _boolean_ - OpenSSH extension that binds to a UNIX domain socket at `socketPath` on the server and forwards incoming connections. `callback` has 1 parameter: < _Error_ >err. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **openssh_unforwardInStreamLocal**(< _string_ >socketPath, < _function_ >callback) - _boolean_ - OpenSSH extension that unbinds from a UNIX domain socket at `socketPath` on the server and stops forwarding incoming connections. `callback` has 1 parameter: < _Error_ >err. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **openssh_forwardOutStreamLocal**(< _string_ >socketPath, < _function_ >callback) - _boolean_ - OpenSSH extension that opens a connection to a UNIX domain socket at `socketPath` on the server. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n\nServer events\n-------------\n\n* **connection**(< _Connection_ >client, < _object_ >info) - A new client has connected. `info` contains the following properties:\n\n    * **ip** - _string_ - The remoteAddress of the connection.\n\n    * **header** - _object_ - Information about the client's header:\n\n        * **identRaw** - _string_ - The raw client identification string.\n\n        * **versions** - _object_ - Various version information:\n\n            * **protocol** - _string_ - The SSH protocol version (always `1.99` or `2.0`).\n\n            * **software** - _string_ - The software name and version of the client.\n\n        * **comments** - _string_ - Any text that comes after the software name/version.\n\n    Example: the identification string `SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2` would be parsed as:\n\n```javascript\n        { identRaw: 'SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2',\n          version: {\n            protocol: '2.0',\n            software: 'OpenSSH_6.6.1p1'\n          },\n          comments: 'Ubuntu-2ubuntu2' }\n```\n\nServer methods\n--------------\n\n* **(constructor)**(< _object_ >config[, < _function_ >connectionListener]) - Creates and returns a new Server instance. Server instances also have the same methods/properties/events as [`net.Server`](http://nodejs.org/docs/latest/api/net.html#net_class_net_server). `connectionListener` if supplied, is added as a `connection` listener. Valid `config` properties:\n\n    * **privateKey** - _mixed_ - Buffer or string that contains the host private key (OpenSSH format). (**Required**) **Default:** (none)\n\n    * **passphrase** - _string_ - For an encrypted host private key, this is the passphrase used to decrypt it. **Default:** (none)\n\n    * **banner** - _string_ - A message that is sent to clients immediately upon connection, before handshaking begins. **Default:** (none)\n\n    * **ident** - _string_ - A custom server software name/version identifier. **Default:** `'ssh2js' + moduleVersion + 'srv'`\n\n    * **highWaterMark** - _integer_ - This is the `highWaterMark` to use for the parser stream. **Default:** `32 * 1024`\n\n    * **debug** - _function_ - Set this to a function that receives a single string argument to get detailed (local) debug information. **Default:** (none)\n\n\nConnection events\n-----------------\n\n* **authentication**(< _AuthContext_ >ctx) - The client has requested authentication. `ctx.username` contains the client username, `ctx.method` contains the requested authentication method, and `ctx.accept()` and `ctx.reject([< Array >authMethodsLeft[, < Boolean >isPartialSuccess]])` are used to accept or reject the authentication request respectively. `abort` is emitted if the client aborts the authentication request. Other properties/methods available on `ctx` depends on the `ctx.method` of authentication the client has requested:\n\n    * `password`:\n\n        * **password** - _string_ - This is the password sent by the client.\n\n    * `publickey`:\n\n        * **key** - _object_ - Contains information about the public key sent by the client:\n\n            * **algo** - _string_ - The name of the key algorithm (e.g. `ssh-rsa`).\n\n            * **data** - _Buffer_ - The actual key data.\n\n        * **sigAlgo** - _mixed_ - If the value is `undefined`, the client is only checking the validity of the `key`. If the value is a _string_, then this contains the signature algorithm that is passed to [`crypto.createVerify()`](http://nodejs.org/docs/latest/api/crypto.html#crypto_crypto_createverify_algorithm).\n\n        * **blob** - _mixed_ - If the value is `undefined`, the client is only checking the validity of the `key`. If the value is a _Buffer_, then this contains the data that is passed to [`verifier.update()`](http://nodejs.org/docs/latest/api/crypto.html#crypto_verifier_update_data).\n\n        * **signature** - _mixed_ - If the value is `undefined`, the client is only checking the validity of the `key`. If the value is a _Buffer_, then this contains a signature that is passed to [`verifier.verify()`](http://nodejs.org/docs/latest/api/crypto.html#crypto_verifier_verify_object_signature_signature_format).\n\n    * `keyboard-interactive`:\n\n        * **submethods** - _array_ - A list of preferred authentication \"sub-methods\" sent by the client. This may be used to determine what (if any) prompts to send to the client.\n\n        * **prompt**(< _array_ >prompts[, < _string_ >title[, < _string_ >instructions]], < _function_ >callback) - _boolean_ - Send prompts to the client. `prompts` is an array of `{ prompt: 'Prompt text', echo: true }` objects (`prompt` being the prompt text and `echo` indicating whether the client's response to the prompt should be echoed to their display). `callback` is called with `(err, responses)`, where `responses` is an array of string responses matching up to the `prompts`.\n\n* **ready**() - Emitted when the client has been successfully authenticated.\n\n* **session**(< _function_ >accept, < _function_ >reject) - Emitted when the client has requested a new session. Sessions are used to start interactive shells, execute commands, request X11 forwarding, etc. `accept()` returns a new _Session_ instance. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **tcpip**(< _function_ >accept, < _function_ >reject, < _object_ >info) - Emitted when the client has requested an outbound (TCP) connection. `accept()` returns a new _Channel_ instance representing the connection. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic. `info` contains:\n\n    * **srcIP** - _string_ - Source IP address of outgoing connection.\n\n    * **srcPort** - _string_ - Source port of outgoing connection.\n\n    * **destIP** - _string_ - Destination IP address of outgoing connection.\n\n    * **destPort** - _string_ - Destination port of outgoing connection.\n\n* **openssh.streamlocal**(< _function_ >accept, < _function_ >reject, < _object_ >info) - Emitted when the client has requested a connection to a UNIX domain socket. `accept()` returns a new _Channel_ instance representing the connection. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic. `info` contains:\n\n    * **socketPath** - _string_ - Destination socket path of outgoing connection.\n\n* **request**(< _mixed_ >accept, < _mixed_ >reject, < _string_ >name, < _object_ >info) - Emitted when the client has sent a global request for `name` (e.g. `tcpip-forward` or `cancel-tcpip-forward`). `accept` and `reject` are functions if the client requested a response. If `bindPort === 0`, you should pass the chosen port to `accept()` so that the client will know what port was bound. `info` contains additional details about the request:\n\n    * `tcpip-forward` and `cancel-tcpip-forward`:\n\n        * **bindAddr** - _string_ - The IP address to start/stop binding to.\n\n        * **bindPort** - _integer_ - The port to start/stop binding to.\n\n    * `streamlocal-forward@openssh.com` and `cancel-streamlocal-forward@openssh.com`:\n\n        * **socketPath** - _string_ - The socket path to start/stop binding to.\n\n* **rekey**() - Emitted when the client has finished rekeying (either client or server initiated).\n\n* **continue**() - Emitted when more requests/data can be sent to the client (after a `Connection` method returned `false`).\n\n* **error**(< _Error_ >err) - An error occurred.\n\n* **end**() - The client socket disconnected.\n\n* **close**(< _boolean_ >hadError) - The client socket was closed. `hadError` is set to `true` if this was due to error.\n\nConnection methods\n------------------\n\n* **end**() - _boolean_ - Closes the client connection. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **x11**(< _string_ >originAddr, < _integer_ >originPort, < _function_ >callback) - _boolean_ - Alert the client of an incoming X11 client connection from `originAddr` on port `originPort`. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **forwardOut**(< _string_ >boundAddr, < _integer_ >boundPort, < _string_ >remoteAddr, < _integer_ >remotePort, < _function_ >callback) - _boolean_ - Alert the client of an incoming TCP connection on `boundAddr` on port `boundPort` from `remoteAddr` on port `remotePort`. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **openssh_forwardOutStreamLocal**(< _string_ >socketPath, < _function_ >callback) - _boolean_ - Alert the client of an incoming UNIX domain socket connection on `socketPath`. `callback` has 2 parameters: < _Error_ >err, < _Channel_ >stream. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **rekey**([< _function_ >callback]) - _boolean_ - Initiates a rekeying with the client. If `callback` is supplied, it is added as a one-time handler for the `rekey` event. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n\nSession events\n--------------\n\n* **pty**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client requested allocation of a pseudo-TTY for this session. `accept` and `reject` are functions if the client requested a response and return `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **cols** - _integer_ - The number of columns for the pseudo-TTY.\n\n    * **rows** - _integer_ - The number of rows for the pseudo-TTY.\n\n    * **width** - _integer_ - The width of the pseudo-TTY in pixels.\n\n    * **height** - _integer_ - The height of the pseudo-TTY in pixels.\n\n    * **modes** - _object_ - Contains the requested terminal modes of the pseudo-TTY keyed on the mode name with the value being the mode argument. (See the table at the end for valid names).\n\n* **window-change**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client reported a change in window dimensions during this session. `accept` and `reject` are functions if the client requested a response and return `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **cols** - _integer_ - The new number of columns for the client window.\n\n    * **rows** - _integer_ - The new number of rows for the client window.\n\n    * **width** - _integer_ - The new width of the client window in pixels.\n\n    * **height** - _integer_ - The new height of the client window in pixels.\n\n* **x11**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client requested X11 forwarding. `accept` and `reject` are functions if the client requested a response and return `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **single** - _boolean_ - `true` if only a single connection should be forwarded.\n\n    * **protocol** - _string_ - The name of the X11 authentication method used (e.g. `MIT-MAGIC-COOKIE-1`).\n\n    * **cookie** - _string_ - The X11 authentication cookie encoded in hexadecimal.\n\n    * **screen** - _integer_ - The screen number to forward X11 connections for.\n\n* **signal**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client has sent a signal. `accept` and `reject` are functions if the client requested a response and return `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **name** - _string_ - The signal name (e.g. `SIGUSR1`).\n\n* **auth-agent**(< _mixed_ >accept, < _mixed_ >reject) - The client has requested incoming ssh-agent requests be forwarded to them. `accept` and `reject` are functions if the client requested a response and return `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **shell**(< _mixed_ >accept, < _mixed_ >reject) - The client has requested an interactive shell. `accept` and `reject` are functions if the client requested a response. `accept()` returns a _Channel_ for the interactive shell. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* **exec**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client has requested execution of a command string. `accept` and `reject` are functions if the client requested a response. `accept()` returns a _Channel_ for the command execution. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **command** - _string_ - The command line to be executed.\n\n* **sftp**(< _mixed_ >accept, < _mixed_ >reject) - The client has requested the SFTP subsystem. `accept` and `reject` are functions if the client requested a response. `accept()` returns an _SFTPStream_ in server mode (see the [`SFTPStream` documentation](https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md) for details). `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n* **subsystem**(< _mixed_ >accept, < _mixed_ >reject, < _object_ >info) - The client has requested an arbitrary subsystem. `accept` and `reject` are functions if the client requested a response. `accept()` returns a _Channel_ for the subsystem. `reject()` Returns `false` if you should wait for the `continue` event before sending any more traffic. `info` has these properties:\n\n    * **name** - _string_ - The name of the subsystem.\n\n* **close**() - The session was closed.\n\n\nChannel\n-------\n\nThis is a normal **streams2** Duplex Stream, with the following changes:\n\n* A boolean property `allowHalfOpen` exists and behaves similarly to the property of the same name for `net.Socket`. When the stream's end() is called, if `allowHalfOpen` is `true`, only EOF will be sent (the server can still send data if they have not already sent EOF). The default value for this property is `true`.\n\n* A `close` event is emitted once the channel is completely closed on both the client and server.\n\n* Client-only:\n\n\n    * For exec():\n\n        * An `exit` event *may* (the SSH2 spec says it is optional) be emitted when the process finishes. If the process finished normally, the process's return value is passed to the `exit` callback. If the process was interrupted by a signal, the following are passed to the `exit` callback: null, < _string_ >signalName, < _boolean_ >didCoreDump, < _string_ >description.\n\n        * If there was an `exit` event, the `close` event will be passed the same arguments for convenience.\n\n    * For shell() and exec():\n\n        * The readable side represents stdout and the writable side represents stdin.\n\n        * A `stderr` property contains a Readable stream that represents output from stderr.\n\n        * **signal**(< _string_ >signalName) - _boolean_ - Sends a POSIX signal to the current process on the server. Valid signal names are: 'ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT', 'KILL', 'PIPE', 'QUIT', 'SEGV', 'TERM', 'USR1', and 'USR2'. Some server implementations may ignore this request if they do not support signals. Note: If you are trying to send SIGINT and you find `signal()` doesn't work, try writing `'\\x03'` to the Channel stream instead. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n        * **setWindow**(< _integer_ >rows, < _integer_ >cols, < _integer_ >height, < _integer_ >width) - _boolean_ - Lets the server know that the local terminal window has been resized. The meaning of these arguments are described in the 'Pseudo-TTY settings' section. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n* Server-only:\n\n    * For exec-enabled channel instances there is an additional method available that may be called right before you close the channel. It has two different signatures:\n\n        * **exit**(< _integer_ >exitCode) - _boolean_ - Sends an exit status code to the client. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n        * **exit**(< _string_ >signalName[, < _boolean_ >coreDumped[, < _string_ >errorMsg]]) - _boolean_ - Sends an exit status code to the client. Returns `false` if you should wait for the `continue` event before sending any more traffic.\n\n    * For exec and shell-enabled channel instances, `channel.stderr` is a writable stream.\n\n\nPseudo-TTY settings\n-------------------\n\n* **rows** - < _integer_ > - Number of rows **Default:** `24`\n\n* **cols** - < _integer_ > - Number of columns **Default:** `80`\n\n* **height** - < _integer_ > - Height in pixels **Default:** `480`\n\n* **width** - < _integer_ > - Width in pixels **Default:** `640`\n\n* **term** - < _string_ > - The value to use for $TERM **Default:** `'vt100'`\n\n`rows` and `cols` override `width` and `height` when `rows` and `cols` are non-zero.\n\nPixel dimensions refer to the drawable area of the window.\n\nZero dimension parameters are ignored.\n\n\nTerminal modes\n--------------\n\n<pre>\nName           Description\n------------------------------------------------------------\nVINTR          Interrupt character; 255 if none.  Similarly\n               for the other characters.  Not all of these\n               characters are supported on all systems.\nVQUIT          The quit character (sends SIGQUIT signal on\n               POSIX systems).\nVERASE         Erase the character to left of the cursor.\nVKILL          Kill the current input line.\nVEOF           End-of-file character (sends EOF from the\n               terminal).\nVEOL           End-of-line character in addition to\n               carriage return and/or linefeed.\nVEOL2          Additional end-of-line character.\nVSTART         Continues paused output (normally\n               control-Q).\nVSTOP          Pauses output (normally control-S).\nVSUSP          Suspends the current program.\nVDSUSP         Another suspend character.\nVREPRINT       Reprints the current input line.\nVWERASE        Erases a word left of cursor.\nVLNEXT         Enter the next character typed literally,\n               even if it is a special character\nVFLUSH         Character to flush output.\nVSWTCH         Switch to a different shell layer.\nVSTATUS        Prints system status line (load, command,\n               pid, etc).\nVDISCARD       Toggles the flushing of terminal output.\nIGNPAR         The ignore parity flag.  The parameter\n               SHOULD be 0 if this flag is FALSE,\n               and 1 if it is TRUE.\nPARMRK         Mark parity and framing errors.\nINPCK          Enable checking of parity errors.\nISTRIP         Strip 8th bit off characters.\nINLCR          Map NL into CR on input.\nIGNCR          Ignore CR on input.\nICRNL          Map CR to NL on input.\nIUCLC          Translate uppercase characters to\n               lowercase.\nIXON           Enable output flow control.\nIXANY          Any char will restart after stop.\nIXOFF          Enable input flow control.\nIMAXBEL        Ring bell on input queue full.\nISIG           Enable signals INTR, QUIT, [D]SUSP.\nICANON         Canonicalize input lines.\nXCASE          Enable input and output of uppercase\n               characters by preceding their lowercase\n               equivalents with \"\\\".\nECHO           Enable echoing.\nECHOE          Visually erase chars.\nECHOK          Kill character discards current line.\nECHONL         Echo NL even if ECHO is off.\nNOFLSH         Don't flush after interrupt.\nTOSTOP         Stop background jobs from output.\nIEXTEN         Enable extensions.\nECHOCTL        Echo control characters as ^(Char).\nECHOKE         Visual erase for line kill.\nPENDIN         Retype pending input.\nOPOST          Enable output processing.\nOLCUC          Convert lowercase to uppercase.\nONLCR          Map NL to CR-NL.\nOCRNL          Translate carriage return to newline\n               (output).\nONOCR          Translate newline to carriage\n               return-newline (output).\nONLRET         Newline performs a carriage return\n               (output).\nCS7            7 bit mode.\nCS8            8 bit mode.\nPARENB         Parity enable.\nPARODD         Odd parity, else even.\nTTY_OP_ISPEED  Specifies the input baud rate in\n               bits per second.\nTTY_OP_OSPEED  Specifies the output baud rate in\n               bits per second.\n</pre>\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mscdex/ssh2/issues"
  },
  "homepage": "https://github.com/mscdex/ssh2",
  "_id": "ssh2@0.4.11",
  "_from": "ssh2@^0.4.11"
}
